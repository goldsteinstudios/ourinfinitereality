<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Infinite Reality</title>
    <meta name="description" content="What if reality really is infinite? A pattern discovered across physics, biology, ancient Chinese, and the shape of good conversations.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0c;
            color: #e8e4d9;
            font-family: 'Georgia', serif;
            overflow: hidden;
        }

        /* Opening symbol */
        #opening {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        #opening.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #symbol {
            position: relative;
            width: 200px;
            height: 200px;
        }

        #symbol-circle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #c9a959;
            border-radius: 50%;
            opacity: 0;
            animation: fadeIn 1.5s ease forwards 0.5s;
        }

        #symbol-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: #c9a959;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            animation: fadeIn 1s ease forwards 0s;
            box-shadow: 0 0 20px rgba(201, 169, 89, 0.4);
        }

        #symbol-orbiter {
            position: absolute;
            top: 0;
            left: 50%;
            width: 10px;
            height: 10px;
            background: #e8e4d9;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            animation: fadeIn 1s ease forwards 1.5s, orbit 12s linear infinite 2s;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @keyframes orbit {
            from { transform: translate(-50%, -50%) rotate(0deg) translateX(100px) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg) translateX(100px) rotate(-360deg); }
        }

        #hint {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            color: #555;
            opacity: 0;
            animation: fadeIn 1s ease forwards 3s;
        }

        /* Sphere container */
        #sphere-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #sphere-container.visible {
            opacity: 1;
        }

        /* UI Overlay */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease 0.5s;
        }

        #ui-overlay.visible {
            opacity: 1;
        }

        /* Realm label on hover */
        #realm-label {
            position: absolute;
            padding: 0.6rem 1.2rem;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #333;
            color: #c9a959;
            font-size: 1.1rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        #realm-label.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #realm-label .subtitle {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.3rem;
        }

        /* Navigation hint */
        #nav-hint {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.85rem;
            color: #555;
            text-align: center;
        }

        /* Title */
        #site-title {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.4rem;
            color: #c9a959;
            letter-spacing: 0.1em;
        }

        /* Sidebar */
        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%;
            background: rgba(10, 10, 12, 0.95);
            border-left: 1px solid #222;
            padding: 2rem;
            overflow-y: auto;
            pointer-events: auto;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.5s ease;
        }

        #sidebar.visible {
            opacity: 1;
            transform: translateX(0);
        }

        #sidebar h2 {
            color: #c9a959;
            font-size: 1.1rem;
            font-weight: normal;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #222;
        }

        #sidebar .start-section {
            margin-bottom: 2rem;
        }

        #sidebar .start-item {
            margin-bottom: 1rem;
        }

        #sidebar .start-item a {
            color: #e8e4d9;
            text-decoration: none;
            font-size: 0.95rem;
            transition: color 0.3s ease;
        }

        #sidebar .start-item a:hover {
            color: #c9a959;
        }

        #sidebar .start-item .why {
            display: block;
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.2rem;
        }

        #sidebar h3 {
            color: #888;
            font-size: 0.85rem;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
        }

        #sidebar .realm-list {
            list-style: none;
        }

        #sidebar .realm-list li {
            padding: 0.5rem 0;
            border-bottom: 1px solid #1a1a1c;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #sidebar .realm-list li:hover {
            color: #c9a959;
        }

        #sidebar .realm-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Adjust sphere container when sidebar visible */
        #sphere-container.with-sidebar {
            width: calc(100% - 320px);
        }

        @media (max-width: 768px) {
            #sidebar {
                width: 100%;
                height: auto;
                max-height: 45vh;
                top: auto;
                bottom: 0;
                border-left: none;
                border-top: 1px solid #222;
                transform: translateY(20px);
            }

            #sidebar.visible {
                transform: translateY(0);
            }

            #sphere-container.with-sidebar {
                width: 100%;
                height: 55vh;
            }
        }
    </style>
</head>
<body>
    <!-- Opening Symbol -->
    <div id="opening">
        <div id="symbol">
            <div id="symbol-center"></div>
            <div id="symbol-circle"></div>
            <div id="symbol-orbiter"></div>
        </div>
        <div id="hint">click to enter</div>
    </div>

    <!-- Sphere -->
    <div id="sphere-container"></div>

    <!-- UI -->
    <div id="ui-overlay">
        <div id="site-title">Our Infinite Reality</div>
        <div id="realm-label">
            <div class="name"></div>
            <div class="subtitle">click to explore</div>
        </div>
        <div id="nav-hint">drag to orbit · click realm to enter</div>

        <div id="sidebar">
            <h2>Start Here</h2>
            <div class="start-section">
                <div class="start-item">
                    <a href="translations/chapters/chapter01.html">Chapter 1: The Coordinate System</a>
                    <span class="why">Where everything begins. The two axes.</span>
                </div>
                <div class="start-item">
                    <a href="translations/chapters/chapter11.html">Chapter 11: Void and Function</a>
                    <span class="why">The wheel, the pot, the room. Function IS emptiness.</span>
                </div>
                <div class="start-item">
                    <a href="framework/recursive_structural_model.html">The Recursive Structural Model</a>
                    <span class="why">The core pattern connecting everything.</span>
                </div>
                <div class="start-item">
                    <a href="essays/why_water.html">Why Water?</a>
                    <span class="why">The metaphor that runs through the text.</span>
                </div>
            </div>

            <h3>The Five Realms</h3>
            <ul class="realm-list" id="realm-list"></ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // ═══════════════════════════════════════════════════════════════
    // DATA - The five realms
    // ═══════════════════════════════════════════════════════════════

    const realms = [
        {
            id: 'ddj',
            name: 'Dao De Jing',
            subtitle: '道德經 · The ancient text',
            color: 0xc9a959,
            position: { x: -3.2, y: 0.5, z: 0 },
            link: 'domains/ddj.html'
        },
        {
            id: 'math',
            name: 'Mathematics',
            subtitle: 'e^iπ + 1 = 0 · The formal language',
            color: 0x6495ed,
            position: { x: 0, y: -2.8, z: 1.5 },
            link: 'domains/math.html'
        },
        {
            id: 'physics',
            name: 'Physics',
            subtitle: 'Energy is rotation',
            color: 0x90ee90,
            position: { x: 0, y: 2.8, z: -1.5 },
            link: 'domains/physics.html'
        },
        {
            id: 'bio',
            name: 'Biology',
            subtitle: 'Self/Other · The living pattern',
            color: 0xdda0dd,
            position: { x: 3.2, y: 0.5, z: 0.5 },
            link: 'domains/bio.html'
        },
        {
            id: 'rsm',
            name: 'RSM',
            subtitle: 'Recursive Structural Model',
            color: 0xffa07a,
            position: { x: 0, y: 0, z: 3.5 },
            link: 'domains/rsm.html'
        }
    ];

    // ═══════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════

    let scene, camera, renderer;
    let sceneGroup;
    let realmMeshes = [];
    let hoveredRealm = null;
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };

    // Visual constants
    const REALM_RADIUS = 0.6;
    const CAMERA_DISTANCE = 10;
    const ROTATION_SPEED = 0.003;

    // ═══════════════════════════════════════════════════════════════
    // THREE.JS SETUP
    // ═══════════════════════════════════════════════════════════════

    function init() {
        const container = document.getElementById('sphere-container');

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CAMERA_DISTANCE;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x0a0a0c);
        container.appendChild(renderer.domElement);

        // Group for rotation
        sceneGroup = new THREE.Group();
        scene.add(sceneGroup);

        // Central origin glow
        createCenterGlow();

        // Create realm spheres
        realms.forEach(createRealmSphere);

        // Create connecting threads
        createThreads();

        // Populate sidebar realm list
        populateSidebarRealms();

        // Events
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; hideRealmLabel(); });
        renderer.domElement.addEventListener('wheel', onWheel);
        renderer.domElement.addEventListener('click', onClick);
        window.addEventListener('resize', onResize);

        // Touch support
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd);

        animate();
    }

    function createCenterGlow() {
        // Core
        const coreGeo = new THREE.SphereGeometry(0.15, 32, 32);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xc9a959, transparent: true, opacity: 0.9 });
        sceneGroup.add(new THREE.Mesh(coreGeo, coreMat));

        // Halo
        const haloGeo = new THREE.SphereGeometry(0.4, 32, 32);
        const haloMat = new THREE.MeshBasicMaterial({ color: 0xc9a959, transparent: true, opacity: 0.1 });
        sceneGroup.add(new THREE.Mesh(haloGeo, haloMat));

        // Outer ring
        const ringGeo = new THREE.RingGeometry(0.5, 0.52, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xc9a959, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        sceneGroup.add(ring);
    }

    function createRealmSphere(realm) {
        const group = new THREE.Group();
        group.position.set(realm.position.x, realm.position.y, realm.position.z);

        // Main sphere
        const sphereGeo = new THREE.SphereGeometry(REALM_RADIUS, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({
            color: realm.color,
            transparent: true,
            opacity: 0.7
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        group.add(sphere);

        // Wireframe
        const wireGeo = new THREE.SphereGeometry(REALM_RADIUS * 1.02, 16, 16);
        const wireMat = new THREE.MeshBasicMaterial({
            color: realm.color,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        group.add(new THREE.Mesh(wireGeo, wireMat));

        // Glow halo
        const glowGeo = new THREE.SphereGeometry(REALM_RADIUS * 1.3, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({
            color: realm.color,
            transparent: true,
            opacity: 0.1
        });
        group.add(new THREE.Mesh(glowGeo, glowMat));

        sceneGroup.add(group);
        realmMeshes.push({ group, sphere, realm, baseMaterial: sphereMat });
    }

    function createThreads() {
        // Connect each realm to center with subtle curved lines
        realms.forEach(realm => {
            const points = [];
            const start = new THREE.Vector3(0, 0, 0);
            const end = new THREE.Vector3(realm.position.x, realm.position.y, realm.position.z);

            // Create curved path
            const mid = new THREE.Vector3().lerpVectors(start, end, 0.5);
            mid.y += 0.5; // slight curve

            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const curvePoints = curve.getPoints(30);

            const lineGeo = new THREE.BufferGeometry().setFromPoints(curvePoints);
            const lineMat = new THREE.LineBasicMaterial({
                color: realm.color,
                transparent: true,
                opacity: 0.15
            });
            sceneGroup.add(new THREE.Line(lineGeo, lineMat));
        });
    }

    function populateSidebarRealms() {
        const list = document.getElementById('realm-list');
        list.innerHTML = realms.map(r => `
            <li data-realm="${r.id}">
                <span class="realm-dot" style="background: #${r.color.toString(16).padStart(6, '0')}"></span>
                <span>${r.name}</span>
            </li>
        `).join('');

        list.querySelectorAll('li').forEach(li => {
            li.onclick = () => {
                const realm = realms.find(r => r.id === li.dataset.realm);
                if (realm) window.location.href = realm.link;
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════
    // INPUT HANDLERS
    // ═══════════════════════════════════════════════════════════════

    function onMouseDown(e) {
        isDragging = true;
        lastMouse = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
        if (isDragging) {
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            sceneGroup.rotation.y += dx * ROTATION_SPEED;
            sceneGroup.rotation.x += dy * ROTATION_SPEED;
            // Clamp vertical rotation
            sceneGroup.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, sceneGroup.rotation.x));
            lastMouse = { x: e.clientX, y: e.clientY };
        }

        // Hover detection
        const hit = raycast(e);
        if (hit) {
            if (hoveredRealm !== hit.realm) {
                hoveredRealm = hit.realm;
                showRealmLabel(hit.realm, e);
                highlightRealm(hit);
                renderer.domElement.style.cursor = 'pointer';
            }
        } else {
            if (hoveredRealm) {
                unhighlightRealm(hoveredRealm);
                hoveredRealm = null;
            }
            hideRealmLabel();
            renderer.domElement.style.cursor = isDragging ? 'grabbing' : 'grab';
        }
    }

    let touchStart = null;
    function onTouchStart(e) {
        if (e.touches.length === 1) {
            e.preventDefault();
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            isDragging = true;
            lastMouse = touchStart;
        }
    }

    function onTouchMove(e) {
        if (e.touches.length === 1 && isDragging) {
            e.preventDefault();
            const dx = e.touches[0].clientX - lastMouse.x;
            const dy = e.touches[0].clientY - lastMouse.y;
            sceneGroup.rotation.y += dx * ROTATION_SPEED;
            sceneGroup.rotation.x += dy * ROTATION_SPEED;
            sceneGroup.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, sceneGroup.rotation.x));
            lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    }

    function onTouchEnd(e) {
        if (touchStart && e.changedTouches.length === 1) {
            const dx = Math.abs(e.changedTouches[0].clientX - touchStart.x);
            const dy = Math.abs(e.changedTouches[0].clientY - touchStart.y);
            if (dx < 10 && dy < 10) {
                const hit = raycastTouch(e.changedTouches[0]);
                if (hit) window.location.href = hit.realm.link;
            }
        }
        isDragging = false;
        touchStart = null;
    }

    function onWheel(e) {
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(6, Math.min(15, camera.position.z));
    }

    function onClick(e) {
        const hit = raycast(e);
        if (hit) {
            window.location.href = hit.realm.link;
        }
    }

    function raycast(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((e.clientX - rect.left) / rect.width) * 2 - 1,
            -((e.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const spheres = realmMeshes.map(r => r.sphere);
        const hits = raycaster.intersectObjects(spheres);
        if (hits.length) {
            return realmMeshes.find(r => r.sphere === hits[0].object);
        }
        return null;
    }

    function raycastTouch(touch) {
        const rect = renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((touch.clientX - rect.left) / rect.width) * 2 - 1,
            -((touch.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const spheres = realmMeshes.map(r => r.sphere);
        const hits = raycaster.intersectObjects(spheres);
        if (hits.length) {
            return realmMeshes.find(r => r.sphere === hits[0].object);
        }
        return null;
    }

    // ═══════════════════════════════════════════════════════════════
    // UI UPDATES
    // ═══════════════════════════════════════════════════════════════

    function showRealmLabel(realm, e) {
        const label = document.getElementById('realm-label');
        label.querySelector('.name').textContent = realm.name;
        label.querySelector('.subtitle').textContent = realm.subtitle;
        label.style.left = (e.clientX + 20) + 'px';
        label.style.top = (e.clientY - 20) + 'px';
        label.classList.add('visible');
    }

    function hideRealmLabel() {
        document.getElementById('realm-label').classList.remove('visible');
    }

    function highlightRealm(hit) {
        hit.baseMaterial.opacity = 0.9;
    }

    function unhighlightRealm(realm) {
        const mesh = realmMeshes.find(r => r.realm === realm);
        if (mesh) mesh.baseMaterial.opacity = 0.7;
    }

    function onResize() {
        const container = document.getElementById('sphere-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // Gentle auto-rotation when not dragging
        if (!isDragging) {
            sceneGroup.rotation.y += 0.001;
        }

        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════

    document.getElementById('opening').onclick = () => {
        document.getElementById('opening').classList.add('hidden');
        document.getElementById('sphere-container').classList.add('visible');
        document.getElementById('sphere-container').classList.add('with-sidebar');
        document.getElementById('ui-overlay').classList.add('visible');
        document.getElementById('sidebar').classList.add('visible');
        init();
    };
    </script>
</body>
</html>
